
std::this_thread::sleep_for(std::chrono::seconds(1));

Do głównych wiadomości żeby wejść w funkcję jest jeden bufor typu char[512]; Ten bufor jest do ogólnych komunikatów co serwer ma zrobić.
Potem w funkcjach są już inne i są wyszczególnione w opisach na dole.


1. Serwer startuje.
2. Osobny wątek zaczyna nasłuchiwać na połączenia.
3. Wątek w mainie po dodaniu nowego klienta nasłuchuje jego wiadomości.

4. Funkcja clientValidation():
Po włączeniu programu i połączeniem się z serwerem, należy się zalogować/zarejestrować.
WYŚLIJ SYGNAŁ: "CLIENT-VALIDATION\0"
Wtedy wchodzi osobny wątek na to w serwerze.
1. Klient wysyła bufor typu char[10] z danymi o typie połączena. Logowanie = 1, rejestracja = 2. Serwer to czyta.
2. Następnie wysyła char[100]: "login-haslo". Serwer czyta to.
3. W przypadku logowania jak i rejestracji jeśli pomyślne to 
serwer wyśle "AUTH-OK\0", a jak fail to "AUTH-FAIL\0".
Logowanie daje fail jak login lub haslo nie znalezione w bazie, a rejestracja jak nick jest zajęty.

5. Po zalogowaniu itp. Klient niech wysyła co sekundę wiadomość typu: "SEND-SESSION-DATA\0" i wtedy odbierze te dane. Ta funkcja do odbierania jest w kliencie starym. 
To to:

  char msg[1024]; //TODO: WIEKSZY ROZMIAR BUFORA???
        readData(clientFd, msg, sizeof(msg)); //FIXME: MUTTTEX MOZE BO BLOKADA PRZY WATKU

        if(msg[0] == '\0'){
            printf("No sessions available.\n");
        }
        else {
            printf("Sessions found.\n");
            playerSessions.clear();
            players.clear();
            char* s;
            s = strtok(msg,":"); // TODO: jak nie zadziała to daj ze delimiter ma wsystkie znaki
            if (s == nullptr){ //TODO: czy to sprawdzać wogóle
                //error;
                printf("strtok error.\n");
            }
            long int numSessions = strtol(s, nullptr, 10);
            for( int i =0; i < numSessions; i++ ) {
                s = strtok(msg, "-");
                long int sessionID = strtol(s, nullptr, 10);
                s = strtok(msg, ",");
                long int numPlayers = strtol(s, nullptr, 10);
                for (int j = 0; j < numPlayers; j++) {
                    s = strtok(msg, ",;");
                    players.push_back(std::string(s));
                }
                playerSessions.insert(std::pair<int, std::vector<std::string>>(sessionID, players));


6. Funkcja joinSession(): używany do odbioru i wysyłania bufor char[100]. 
Klient powinien obsługiwać taką sytuację, że jak 4 graczy w sesji na dany moemnt to od razu nie pozwala się połączyć bo bez sensu.
Do tego jakaś zmienna bool'owska w kliencie ze jest w sesji i wtedy nie moze dolaczyc do nowej.
Klient dołącza/tworzy sesje.
Żeby dołączyć do sesji klient musi wysłać wiadomość: "JOIN-SESSION\0".
Wtedy serwer włącza wątek który obsłuży to, ten wątek. Join session oczekuje bufora char[20] z numerem sesji.
Czeka na sessionMode, 0 - tworzy nową sesje; > 0 to id istniejacej sesji i wtedy dołączyć próbuje.
Potem join session operuje na buforze typu char[100] wysyłając odpowiedź.
- Typy wysyłanych danych przez serwer:
* "SESSION-1\0" nowa sesja stworzona nie ma innych;
* "SESSION-tutaj numer\0" nowa sesja o numerze, lub dołączanie do istniejącej;
* "SESSION-MAX\0"  nie można stworzyć sesji limit przekroczony;
* "SESSION-BUSY\0" sesja jest pełna, nie da sie dolaczyc;


7. Funkcja sessionLoop():
Tutaj powinno być tak, że jak stworzył sesję ktoś to KLIENT pamięta ze jest hostem i wtedy tylko host może wysłać sygnał
"START-SESSION\0", który odpala sesję. Serwer sprawdzi w ktorej jest i ja odpali. Klient sprawdza czy jest min 2 graczy jak nie to nie startuje sesji. Jak juz wystartuje dostaje odpowiedz zwrotna: jak OK to dostaje "START-SESSION-OK\0", jak za mało graczy jednak to "START-SESSION-FAIL\0".

-Następnie każdy klient czeka na wylosowane słowo. Jak na razie czas na każdą rundę taki sam więc nie ma sensu żeby serwer to wysyłał.
 Po otrzymaniu słowa klie0nt ma 2 minuty na odgadnięcie. Bufor char[100] na każde słowo. Po otrzymaniu słowa niech klient wylicza ile błędów    może popełnić:
Taki wzorek stworzyłem.
* int mistakesPerWord = 0;
* mistakesPerWord = std::max((int)(randomWord.length()/3), 2); //Gdzie randomWord to wylosowane słowo otrzymane.
* Bonus jak mierzyć czas
        auto start = std::chrono::steady_clock::now(); 
	//runda
	end = std::chrono::steady_clock::now();
        auto time_span = static_cast<std::chrono::duration<double>>(end - start);
	double seconds = time_span.count();

- Z każdą rundą serwer sprawdza ilość graczy. Jak poniżej 2 to sesja wysyła (jeśli jest 1) komunikat "SESSION-TIMEOUT\0" i na 10 sekund sesja śpi. Jeśli po 10 sekundach nie ma dalej 2 lub wiecej graczy to wiadomość do (jeśli jest 1) "SESSION-KILL\0"  i wtedy sesja usuwana i koniec jej.   
- Z początkiem każdej rundy wiadomość "ROUND-START\0";
- Losowane słowo i sprawdzane czy było już użyte, żeby były unikalne. Wysyłany bufor char buf[100] (ze słowem);
- W tym czasie klient sprawdza poprawność tego co wpisuje gracz. Jak poprawnie i w czasie się miesci to musi wysłać wiadomość, która jest sekundami z tak kilkoma (do 5 ?) miejscami po przecinku. Czyli ile czasu zajęło buforem char[50]. Po niej serwer czeka z 3 sekundy na inne  wiadomości.
- Na razie 4 rundy plus jedna mozliwa dogywka co da 5.
- Bufor char[50] czeka na odpowiedź od klienta z jego czasem. Czas na turę to 120 sekund.
- Wyłonienie zwycięzcy: 
	* "WIN-0\0" nikt nie wygrał;
	* "WIN-NICKNAME_UZYTKOWNIKA\0" - nazwa zwyciezcy rundy;
- Przy czwartej rundzie sprawdzenie czy ktoś ma remis jak tak to 5 runda.
- Na koniec wysłanie scoreBoard'a, który jest buforem char[1024], wysyła nie posortowane:
	* "NICK_GRACZA:punkty\n" i tak dalej, czyli graczy oddziela '\n';
		przykład wiadomości: "JANEKbangladeszKOMANDO:2\n"
- Sesja kończy się wyrzucenie z niej graczy.




* DO DOROBIENIA:  -------------------------------------------------IMPORANTE MUCHACHO---------------
- POPRAWNE ZAMYKANIE SERWERA!; na razie nie jest bo musze dorobic ze:
- ładnie się zamknie watek nasluchiwania;
- gowny watek wyjdzie z epolla;
- poboczne watki jesli sa to wyjebac;
- dac sygnal klientom ze koniec???? TUTAJ KLIENT MUSIALBY MIEC SPRAWDZANIE ZE JAK readData na sockecie da zero to koniec połączenia
- SESSION LOOP ODBIERANIE PORGRESU PRZESYŁANIE;


